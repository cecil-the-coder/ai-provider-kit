{"id":"workspace-0ha","title":"APK 3.2: Add Metrics Handler","description":"**Task 3.2: Add Metrics Handler**\n\n**Priority:** P1 - High\n**Estimated Effort:** 6 hours\n\n**Features:**\n- Provider metrics endpoint\n- System metrics endpoint\n- Racing performance metrics endpoint\n\n**Acceptance Criteria:**\n- [ ] Provider metrics endpoint\n- [ ] System metrics endpoint\n- [ ] Racing performance metrics endpoint\n\n**Context:**\nThis task is part of Phase 3: Integration (Week 5-6) for the AI-PROVIDER-KIT component. It focuses on adding metrics collection and reporting capabilities to monitor provider performance, system health, and racing algorithm effectiveness.","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:46.23127434Z","updated_at":"2025-11-29T02:05:13.140852527Z","dependencies":[{"issue_id":"workspace-0ha","depends_on_id":"workspace-sqx","type":"blocks","created_at":"2025-11-29T02:00:40.341629509Z","created_by":"daemon"}]}
{"id":"workspace-1nh","title":"APK 2.2: Implement Provider Management Handler","description":"#### Task 2.2: Implement Provider Management Handler\n**Priority:** P0 - Blocking\n**Estimated Effort:** 8 hours\n\n**File:** `pkg/backend/handlers/providers.go`\n\n**Features:**\n- List providers\n- Get provider details\n- Update provider configuration\n- Provider health checking\n- Provider testing endpoint\n- Virtual provider support\n\n**Acceptance Criteria:**\n- [ ] List, Get, Update providers\n- [ ] Provider health checking\n- [ ] Provider testing endpoint\n- [ ] Virtual provider support\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:41.694171306Z","updated_at":"2025-11-29T02:04:37.940748553Z","dependencies":[{"issue_id":"workspace-1nh","depends_on_id":"workspace-uud","type":"blocks","created_at":"2025-11-29T02:00:39.238774367Z","created_by":"daemon"}]}
{"id":"workspace-1x4","title":"APK 2.4: Implement Health and Status Handlers","description":"#### Task 2.4: Implement Health and Status Handlers\n**Priority:** P1 - High\n**Estimated Effort:** 4 hours\n\n**File:** `pkg/backend/handlers/health.go`\n\n**Acceptance Criteria:**\n- [ ] Status endpoint\n- [ ] Health endpoint with provider health\n- [ ] Version information\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:43.570379278Z","updated_at":"2025-11-29T02:04:49.290018429Z","dependencies":[{"issue_id":"workspace-1x4","depends_on_id":"workspace-uud","type":"blocks","created_at":"2025-11-29T02:00:39.2596464Z","created_by":"daemon"}]}
{"id":"workspace-2fy","title":"APK 1.8: Create Core Middleware","description":"#### Task 1.8: Create Core Middleware\n**Priority:** P0 - Blocking\n**Estimated Effort:** 4 hours\n\n**Files to create:**\n- [ ] `pkg/backend/middleware/requestid.go` - Request ID generation\n- [ ] `pkg/backend/middleware/cors.go` - CORS handling\n- [ ] `pkg/backend/middleware/logging.go` - Request logging\n- [ ] `pkg/backend/middleware/recovery.go` - Panic recovery\n- [ ] `pkg/backend/middleware/auth.go` - Authentication\n\n**Acceptance Criteria:**\n- [ ] All middleware implemented and tested\n- [ ] Middleware follows standard http.Handler pattern\n- [ ] Configuration-driven behavior\n- [ ] Unit tests for each middleware","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:22.707956383Z","updated_at":"2025-11-29T02:04:32.121611273Z","dependencies":[{"issue_id":"workspace-2fy","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.086448065Z","created_by":"daemon"}]}
{"id":"workspace-2ix","title":"APK 1.5: Implement Fallback Virtual Provider","description":"#### Task 1.5: Implement Fallback Virtual Provider\n**Priority:** P0 - Blocking\n**Estimated Effort:** 4 hours\n\n**File:** `pkg/providers/virtual/fallback/provider.go`\n\n```go\npackage fallback\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/anthropics/ai-provider-kit/pkg/types\"\n)\n\n// FallbackProvider tries providers in order until one succeeds\ntype FallbackProvider struct {\n    name      string\n    providers []types.Provider\n    config    *Config\n}\n\ntype Config struct {\n    ProviderNames []string `yaml:\"providers\"`\n    MaxRetries    int      `yaml:\"max_retries\"`\n}\n\nfunc NewFallbackProvider(name string, config *Config) *FallbackProvider {\n    return \u0026FallbackProvider{\n        name:   name,\n        config: config,\n    }\n}\n\nfunc (f *FallbackProvider) SetProviders(providers []types.Provider) {\n    f.providers = providers\n}\n\nfunc (f *FallbackProvider) Name() string              { return f.name }\nfunc (f *FallbackProvider) Type() types.ProviderType { return \"fallback\" }\nfunc (f *FallbackProvider) Description() string      { return \"Tries providers in order until one succeeds\" }\n\nfunc (f *FallbackProvider) GenerateChatCompletion(ctx context.Context, opts types.GenerateOptions) (types.ChatCompletionStream, error) {\n    var lastErr error\n\n    for i, provider := range f.providers {\n        chatProvider, ok := provider.(types.ChatProvider)\n        if !ok {\n            continue\n        }\n\n        stream, err := chatProvider.GenerateChatCompletion(ctx, opts)\n        if err == nil {\n            return \u0026fallbackStream{\n                inner:         stream,\n                providerName:  provider.Name(),\n                providerIndex: i,\n            }, nil\n        }\n\n        lastErr = err\n    }\n\n    if lastErr != nil {\n        return nil, fmt.Errorf(\"all providers failed, last error: %w\", lastErr)\n    }\n    return nil, fmt.Errorf(\"no providers available\")\n}\n\ntype fallbackStream struct {\n    inner         types.ChatCompletionStream\n    providerName  string\n    providerIndex int\n}\n\nfunc (s *fallbackStream) Next() (types.ChatCompletionChunk, error) {\n    chunk, err := s.inner.Next()\n    if chunk.Metadata == nil {\n        chunk.Metadata = make(map[string]interface{})\n    }\n    chunk.Metadata[\"fallback_provider\"] = s.providerName\n    chunk.Metadata[\"fallback_index\"] = s.providerIndex\n    return chunk, err\n}\n\nfunc (s *fallbackStream) Close() error {\n    return s.inner.Close()\n}\n```\n\n**Acceptance Criteria:**\n- [ ] Fallback provider implements types.Provider\n- [ ] Tries providers in order\n- [ ] Returns first successful response\n- [ ] Proper error aggregation\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:18.434416673Z","updated_at":"2025-11-29T02:04:38.155630442Z","dependencies":[{"issue_id":"workspace-2ix","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.055851386Z","created_by":"daemon"}]}
{"id":"workspace-2xd","title":"APK 2.3: Implement Generation Handler","description":"#### Task 2.3: Implement Generation Handler\n**Priority:** P0 - Blocking\n**Estimated Effort:** 8 hours\n\n**File:** `pkg/backend/handlers/generate.go`\n\n**Acceptance Criteria:**\n- [ ] Generate endpoint with extension hooks\n- [ ] Provider selection (including virtual providers)\n- [ ] Error handling with extension notification\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:42.494615461Z","updated_at":"2025-11-29T02:04:48.197452593Z","dependencies":[{"issue_id":"workspace-2xd","depends_on_id":"workspace-uud","type":"blocks","created_at":"2025-11-29T02:00:39.248923053Z","created_by":"daemon"}]}
{"id":"workspace-30d","title":"APK 1.1: Create Package Structure","description":"### Task 1.1: Create Package Structure\n**Priority:** P0 - Blocking\n**Estimated Effort:** 2 hours\n\nCreate the new package structure:\n\n```bash\nmkdir -p pkg/backend/{handlers,middleware,extensions}\nmkdir -p pkg/backendtypes\nmkdir -p pkg/providers/virtual/{racing,fallback,loadbalance}\n```\n\n**Files to create:**\n- [ ] `pkg/backend/doc.go` - Package documentation\n- [ ] `pkg/backendtypes/doc.go` - Package documentation\n- [ ] `pkg/providers/virtual/doc.go` - Virtual providers documentation\n\n**Acceptance Criteria:**\n- Package structure created\n- Documentation explains purpose of each package","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:14.654679625Z","updated_at":"2025-11-29T02:04:30.026222118Z"}
{"id":"workspace-30w","title":"APK 3.4: Register Virtual Providers in Factory","description":"**Task 3.4: Register Virtual Providers in Factory**\n\n**Priority:** P0 - Blocking\n**Estimated Effort:** 4 hours\n\nUpdate factory to register virtual providers:\n\n```go\nfunc RegisterDefaultProviders(f ProviderFactory) {\n    // Real providers\n    f.RegisterProvider(\"openai\", openai.NewProvider)\n    f.RegisterProvider(\"anthropic\", anthropic.NewProvider)\n    // ... other providers\n\n    // Virtual providers\n    f.RegisterProvider(\"racing\", racing.NewRacingProvider)\n    f.RegisterProvider(\"fallback\", fallback.NewFallbackProvider)\n    f.RegisterProvider(\"loadbalance\", loadbalance.NewLoadBalanceProvider)\n}\n```\n\n**Features:**\n- Virtual providers registered in factory\n- Configuration parsing for virtual providers\n- Dependency resolution (racing depends on other providers)\n\n**Acceptance Criteria:**\n- [ ] Virtual providers registered in factory\n- [ ] Virtual provider configuration parsing\n- [ ] Provider dependency resolution (racing depends on other providers)\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:58.041033403Z","updated_at":"2025-11-29T02:04:56.86252788Z","dependencies":[{"issue_id":"workspace-30w","depends_on_id":"workspace-co0","type":"blocks","created_at":"2025-11-29T02:00:40.36448143Z","created_by":"daemon"},{"issue_id":"workspace-30w","depends_on_id":"workspace-2ix","type":"blocks","created_at":"2025-11-29T02:00:40.374955392Z","created_by":"daemon"},{"issue_id":"workspace-30w","depends_on_id":"workspace-xzt","type":"blocks","created_at":"2025-11-29T02:00:40.386779749Z","created_by":"daemon"}]}
{"id":"workspace-9s5","title":"APK 3.3: Add Streaming Support","description":"#### Task 3.3: Add Streaming Support\n**Priority:** P1 - High\n**Estimated Effort:** 8 hours\n\n**Features:**\n- SSE endpoint for streaming generation\n- Proper connection handling\n- Extension hooks for streaming\n\n**Acceptance Criteria:**\n- [ ] SSE endpoint for streaming generation\n- [ ] Proper connection handling\n- [ ] Extension hooks for streaming","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:47.054071964Z","updated_at":"2025-11-29T02:04:57.63204071Z","dependencies":[{"issue_id":"workspace-9s5","depends_on_id":"workspace-sqx","type":"blocks","created_at":"2025-11-29T02:00:40.352362183Z","created_by":"daemon"}]}
{"id":"workspace-co0","title":"APK 1.4: Implement Racing Virtual Provider","description":"#### Task 1.4: Implement Racing Virtual Provider\n**Priority:** P0 - Blocking\n**Estimated Effort:** 8 hours\n\n**File:** `pkg/providers/virtual/racing/provider.go`\n\n```go\npackage racing\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n\n    \"github.com/anthropics/ai-provider-kit/pkg/types\"\n)\n\n// RacingProvider races multiple providers and returns the first successful response\ntype RacingProvider struct {\n    name        string\n    providers   []types.Provider\n    config      *Config\n    performance *PerformanceTracker\n    mu          sync.RWMutex\n}\n\ntype Config struct {\n    TimeoutMS       int      `yaml:\"timeout_ms\"`\n    GracePeriodMS   int      `yaml:\"grace_period_ms\"`\n    Strategy        Strategy `yaml:\"strategy\"`\n    ProviderNames   []string `yaml:\"providers\"`\n    PerformanceFile string   `yaml:\"performance_file,omitempty\"`\n}\n\ntype Strategy string\n\nconst (\n    StrategyFirstWins Strategy = \"first_wins\"\n    StrategyWeighted  Strategy = \"weighted\"\n    StrategyQuality   Strategy = \"quality\"\n)\n\ntype raceResult struct {\n    index    int\n    provider types.Provider\n    stream   types.ChatCompletionStream\n    err      error\n    latency  time.Duration\n}\n\nfunc NewRacingProvider(name string, config *Config) *RacingProvider {\n    return \u0026RacingProvider{\n        name:        name,\n        config:      config,\n        performance: NewPerformanceTracker(),\n    }\n}\n\n// SetProviders sets the providers to race\nfunc (r *RacingProvider) SetProviders(providers []types.Provider) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.providers = providers\n}\n\n// Provider interface implementation\nfunc (r *RacingProvider) Name() string                  { return r.name }\nfunc (r *RacingProvider) Type() types.ProviderType     { return \"racing\" }\nfunc (r *RacingProvider) Description() string          { return \"Races multiple providers for fastest response\" }\n\n// ChatProvider interface implementation\nfunc (r *RacingProvider) GenerateChatCompletion(ctx context.Context, opts types.GenerateOptions) (types.ChatCompletionStream, error) {\n    r.mu.RLock()\n    providers := r.providers\n    r.mu.RUnlock()\n\n    if len(providers) == 0 {\n        return nil, fmt.Errorf(\"no providers configured for racing\")\n    }\n\n    timeout := time.Duration(r.config.TimeoutMS) * time.Millisecond\n    ctx, cancel := context.WithTimeout(ctx, timeout)\n    defer cancel()\n\n    results := make(chan *raceResult, len(providers))\n    var wg sync.WaitGroup\n\n    // Start all providers racing\n    for i, provider := range providers {\n        wg.Add(1)\n        go func(idx int, p types.Provider) {\n            defer wg.Done()\n            start := time.Now()\n\n            chatProvider, ok := p.(types.ChatProvider)\n            if !ok {\n                results \u003c- \u0026raceResult{index: idx, provider: p, err: fmt.Errorf(\"provider does not support chat\")}\n                return\n            }\n\n            stream, err := chatProvider.GenerateChatCompletion(ctx, opts)\n            results \u003c- \u0026raceResult{\n                index:    idx,\n                provider: p,\n                stream:   stream,\n                err:      err,\n                latency:  time.Since(start),\n            }\n        }(i, provider)\n    }\n\n    // Close results channel when all done\n    go func() {\n        wg.Wait()\n        close(results)\n    }()\n\n    // Select winner based on strategy\n    return r.selectWinner(ctx, results)\n}\n\nfunc (r *RacingProvider) selectWinner(ctx context.Context, results chan *raceResult) (types.ChatCompletionStream, error) {\n    switch r.config.Strategy {\n    case StrategyWeighted:\n        return r.weightedStrategy(ctx, results)\n    case StrategyQuality:\n        return r.qualityStrategy(ctx, results)\n    default:\n        return r.firstWinsStrategy(ctx, results)\n    }\n}\n\nfunc (r *RacingProvider) firstWinsStrategy(ctx context.Context, results chan *raceResult) (types.ChatCompletionStream, error) {\n    var lastErr error\n    for result := range results {\n        if result.err == nil \u0026\u0026 result.stream != nil {\n            r.performance.RecordWin(result.provider.Name(), result.latency)\n            return \u0026racingStream{\n                inner:    result.stream,\n                provider: result.provider.Name(),\n                latency:  result.latency,\n            }, nil\n        }\n        if result.err != nil {\n            r.performance.RecordLoss(result.provider.Name(), result.latency)\n            lastErr = result.err\n        }\n    }\n    if lastErr != nil {\n        return nil, fmt.Errorf(\"all providers failed, last error: %w\", lastErr)\n    }\n    return nil, fmt.Errorf(\"all providers failed\")\n}\n\nfunc (r *RacingProvider) weightedStrategy(ctx context.Context, results chan *raceResult) (types.ChatCompletionStream, error) {\n    // Collect results during grace period, pick best based on historical performance\n    gracePeriod := time.Duration(r.config.GracePeriodMS) * time.Millisecond\n    timer := time.NewTimer(gracePeriod)\n    defer timer.Stop()\n\n    var candidates []*raceResult\n\n    for {\n        select {\n        case result, ok := \u003c-results:\n            if !ok {\n                // All results received\n                return r.pickBestCandidate(candidates)\n            }\n            if result.err == nil \u0026\u0026 result.stream != nil {\n                candidates = append(candidates, result)\n                // If we have a result and grace period hasn't started, start it\n                if len(candidates) == 1 {\n                    timer.Reset(gracePeriod)\n                }\n            }\n        case \u003c-timer.C:\n            // Grace period expired, pick from candidates\n            if len(candidates) \u003e 0 {\n                return r.pickBestCandidate(candidates)\n            }\n            // No candidates yet, continue waiting\n        case \u003c-ctx.Done():\n            if len(candidates) \u003e 0 {\n                return r.pickBestCandidate(candidates)\n            }\n            return nil, ctx.Err()\n        }\n    }\n}\n\nfunc (r *RacingProvider) qualityStrategy(ctx context.Context, results chan *raceResult) (types.ChatCompletionStream, error) {\n    // Wait for all results (up to timeout), then pick best\n    return r.weightedStrategy(ctx, results)\n}\n\nfunc (r *RacingProvider) pickBestCandidate(candidates []*raceResult) (types.ChatCompletionStream, error) {\n    if len(candidates) == 0 {\n        return nil, fmt.Errorf(\"no successful candidates\")\n    }\n\n    // Score candidates based on historical performance\n    var best *raceResult\n    var bestScore float64 = -1\n\n    for _, c := range candidates {\n        score := r.performance.GetScore(c.provider.Name())\n        // Adjust score by latency (faster is better)\n        latencyFactor := 1.0 / (1.0 + c.latency.Seconds())\n        adjustedScore := score * latencyFactor\n\n        if adjustedScore \u003e bestScore {\n            bestScore = adjustedScore\n            best = c\n        }\n    }\n\n    if best != nil {\n        r.performance.RecordWin(best.provider.Name(), best.latency)\n        return \u0026racingStream{\n            inner:    best.stream,\n            provider: best.provider.Name(),\n            latency:  best.latency,\n        }, nil\n    }\n\n    // Fallback to first candidate\n    r.performance.RecordWin(candidates[0].provider.Name(), candidates[0].latency)\n    return \u0026racingStream{\n        inner:    candidates[0].stream,\n        provider: candidates[0].provider.Name(),\n        latency:  candidates[0].latency,\n    }, nil\n}\n\n// GetPerformanceStats returns performance statistics for all providers\nfunc (r *RacingProvider) GetPerformanceStats() map[string]*ProviderStats {\n    return r.performance.GetAllStats()\n}\n\n// racingStream wraps a stream with racing metadata\ntype racingStream struct {\n    inner    types.ChatCompletionStream\n    provider string\n    latency  time.Duration\n}\n\nfunc (s *racingStream) Next() (types.ChatCompletionChunk, error) {\n    chunk, err := s.inner.Next()\n    // Add racing metadata to first chunk\n    if chunk.Metadata == nil {\n        chunk.Metadata = make(map[string]interface{})\n    }\n    chunk.Metadata[\"racing_winner\"] = s.provider\n    chunk.Metadata[\"racing_latency_ms\"] = s.latency.Milliseconds()\n    return chunk, err\n}\n\nfunc (s *racingStream) Close() error {\n    return s.inner.Close()\n}\n```\n\n**File:** `pkg/providers/virtual/racing/performance.go`\n\n```go\npackage racing\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\ntype PerformanceTracker struct {\n    mu    sync.RWMutex\n    stats map[string]*ProviderStats\n}\n\ntype ProviderStats struct {\n    TotalRaces   int64         `json:\"total_races\"`\n    Wins         int64         `json:\"wins\"`\n    Losses       int64         `json:\"losses\"`\n    AvgLatency   time.Duration `json:\"avg_latency\"`\n    TotalLatency time.Duration `json:\"-\"`\n    WinRate      float64       `json:\"win_rate\"`\n    LastUpdated  time.Time     `json:\"last_updated\"`\n}\n\nfunc NewPerformanceTracker() *PerformanceTracker {\n    return \u0026PerformanceTracker{\n        stats: make(map[string]*ProviderStats),\n    }\n}\n\nfunc (pt *PerformanceTracker) RecordWin(provider string, latency time.Duration) {\n    pt.mu.Lock()\n    defer pt.mu.Unlock()\n\n    stats := pt.getOrCreate(provider)\n    stats.TotalRaces++\n    stats.Wins++\n    stats.TotalLatency += latency\n    stats.AvgLatency = stats.TotalLatency / time.Duration(stats.TotalRaces)\n    stats.WinRate = float64(stats.Wins) / float64(stats.TotalRaces)\n    stats.LastUpdated = time.Now()\n}\n\nfunc (pt *PerformanceTracker) RecordLoss(provider string, latency time.Duration) {\n    pt.mu.Lock()\n    defer pt.mu.Unlock()\n\n    stats := pt.getOrCreate(provider)\n    stats.TotalRaces++\n    stats.Losses++\n    stats.TotalLatency += latency\n    stats.AvgLatency = stats.TotalLatency / time.Duration(stats.TotalRaces)\n    stats.WinRate = float64(stats.Wins) / float64(stats.TotalRaces)\n    stats.LastUpdated = time.Now()\n}\n\nfunc (pt *PerformanceTracker) GetScore(provider string) float64 {\n    pt.mu.RLock()\n    defer pt.mu.RUnlock()\n\n    stats, ok := pt.stats[provider]\n    if !ok {\n        return 0.5 // Default score for new providers\n    }\n\n    // Score based on win rate (0.0 to 1.0)\n    return stats.WinRate\n}\n\nfunc (pt *PerformanceTracker) GetAllStats() map[string]*ProviderStats {\n    pt.mu.RLock()\n    defer pt.mu.RUnlock()\n\n    result := make(map[string]*ProviderStats)\n    for k, v := range pt.stats {\n        statsCopy := *v\n        result[k] = \u0026statsCopy\n    }\n    return result\n}\n\nfunc (pt *PerformanceTracker) getOrCreate(provider string) *ProviderStats {\n    stats, ok := pt.stats[provider]\n    if !ok {\n        stats = \u0026ProviderStats{}\n        pt.stats[provider] = stats\n    }\n    return stats\n}\n```\n\n**Acceptance Criteria:**\n- [ ] Racing provider implements types.Provider and types.ChatProvider\n- [ ] First-wins strategy implemented\n- [ ] Weighted strategy with grace period implemented\n- [ ] Performance tracking with win rates\n- [ ] Thread-safe implementation\n- [ ] Unit tests for all strategies","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:17.398548382Z","updated_at":"2025-11-29T02:05:08.754115923Z","dependencies":[{"issue_id":"workspace-co0","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.045389978Z","created_by":"daemon"}]}
{"id":"workspace-dm0","title":"APK 4.2: Performance Optimization","description":"#### Task 4.2: Performance Optimization\n**Priority:** P2 - Medium\n**Estimated Effort:** 8 hours\n\n- [ ] Profile and optimize hot paths\n- [ ] Racing provider optimization\n- [ ] Connection pooling","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T02:00:00.00795712Z","updated_at":"2025-11-29T02:05:04.521295663Z","dependencies":[{"issue_id":"workspace-dm0","depends_on_id":"workspace-sqx","type":"blocks","created_at":"2025-11-29T02:00:41.067403809Z","created_by":"daemon"},{"issue_id":"workspace-dm0","depends_on_id":"workspace-30w","type":"blocks","created_at":"2025-11-29T02:00:41.077479909Z","created_by":"daemon"}]}
{"id":"workspace-ezv","title":"APK 1.3: Define API Request/Response Types","description":"#### Task 1.3: Define API Request/Response Types\n**Priority:** P0 - Blocking\n**Estimated Effort:** 4 hours\n\n**File:** `pkg/backendtypes/requests.go`\n\n```go\npackage backendtypes\n\nimport \"github.com/anthropics/ai-provider-kit/pkg/types\"\n\n// GenerateRequest represents a code/chat generation request\ntype GenerateRequest struct {\n    Provider    string                 `json:\"provider,omitempty\"`\n    Model       string                 `json:\"model,omitempty\"`\n    Prompt      string                 `json:\"prompt\"`\n    Messages    []types.ChatMessage    `json:\"messages,omitempty\"`\n    MaxTokens   int                    `json:\"max_tokens,omitempty\"`\n    Temperature float64                `json:\"temperature,omitempty\"`\n    Stream      bool                   `json:\"stream,omitempty\"`\n    Tools       []types.Tool           `json:\"tools,omitempty\"`\n    Metadata    map[string]interface{} `json:\"metadata,omitempty\"`\n}\n\n// ProviderConfigRequest for updating provider configuration\ntype ProviderConfigRequest struct {\n    Type         string   `json:\"type\"`\n    APIKey       string   `json:\"api_key,omitempty\"`\n    APIKeys      []string `json:\"api_keys,omitempty\"`\n    DefaultModel string   `json:\"default_model,omitempty\"`\n    BaseURL      string   `json:\"base_url,omitempty\"`\n    Enabled      bool     `json:\"enabled\"`\n}\n```\n\n**File:** `pkg/backendtypes/responses.go`\n\n```go\npackage backendtypes\n\nimport \"time\"\n\n// APIResponse is the standard response wrapper\ntype APIResponse struct {\n    Success   bool        `json:\"success\"`\n    Data      interface{} `json:\"data,omitempty\"`\n    Error     *APIError   `json:\"error,omitempty\"`\n    RequestID string      `json:\"request_id,omitempty\"`\n    Timestamp time.Time   `json:\"timestamp\"`\n}\n\ntype APIError struct {\n    Code    string `json:\"code\"`\n    Message string `json:\"message\"`\n    Details string `json:\"details,omitempty\"`\n}\n\n// GenerateResponse for code/chat generation\ntype GenerateResponse struct {\n    Content  string                 `json:\"content\"`\n    Model    string                 `json:\"model\"`\n    Provider string                 `json:\"provider\"`\n    Usage    *UsageInfo             `json:\"usage,omitempty\"`\n    Metadata map[string]interface{} `json:\"metadata,omitempty\"`\n}\n\ntype UsageInfo struct {\n    PromptTokens     int `json:\"prompt_tokens\"`\n    CompletionTokens int `json:\"completion_tokens\"`\n    TotalTokens      int `json:\"total_tokens\"`\n}\n\n// ProviderInfo for provider listing\ntype ProviderInfo struct {\n    Name        string   `json:\"name\"`\n    Type        string   `json:\"type\"`\n    Enabled     bool     `json:\"enabled\"`\n    Healthy     bool     `json:\"healthy\"`\n    Models      []string `json:\"models,omitempty\"`\n    Description string   `json:\"description,omitempty\"`\n}\n\n// HealthResponse for health endpoints\ntype HealthResponse struct {\n    Status    string                    `json:\"status\"`\n    Version   string                    `json:\"version\"`\n    Uptime    string                    `json:\"uptime\"`\n    Providers map[string]ProviderHealth `json:\"providers,omitempty\"`\n}\n\ntype ProviderHealth struct {\n    Status  string `json:\"status\"`\n    Latency int64  `json:\"latency_ms\"`\n    Message string `json:\"message,omitempty\"`\n}\n```\n\n**Acceptance Criteria:**\n- [ ] All request types defined with validation tags\n- [ ] All response types defined with JSON tags\n- [ ] Consistent with existing types.* types\n- [ ] Unit tests for serialization/deserialization","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:16.244023832Z","updated_at":"2025-11-29T02:04:40.693218623Z","dependencies":[{"issue_id":"workspace-ezv","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.035154841Z","created_by":"daemon"}]}
{"id":"workspace-fc4","title":"APK 1.7: Create Extension Framework Interface","description":"**Task 1.7: Create Extension Framework Interface**\n\n**Priority:** P0 - Blocking\n**Estimated Effort:** 6 hours\n\n**File:** `pkg/backend/extensions/interface.go`\n\n```go\npackage extensions\n\nimport (\n    \"context\"\n    \"net/http\"\n\n    \"github.com/anthropics/ai-provider-kit/pkg/backendtypes\"\n    \"github.com/anthropics/ai-provider-kit/pkg/types\"\n)\n\n// Extension defines the interface for backend extensions\ntype Extension interface {\n    // Metadata\n    Name() string\n    Version() string\n    Description() string\n    Dependencies() []string\n\n    // Lifecycle\n    Initialize(config map[string]interface{}) error\n    Shutdown(ctx context.Context) error\n\n    // Route registration (optional)\n    RegisterRoutes(registrar RouteRegistrar) error\n\n    // Request/Response hooks (optional - return nil to skip)\n    BeforeGenerate(ctx context.Context, req *backendtypes.GenerateRequest) error\n    AfterGenerate(ctx context.Context, req *backendtypes.GenerateRequest, resp *backendtypes.GenerateResponse) error\n\n    // Provider hooks (optional)\n    OnProviderError(ctx context.Context, provider types.Provider, err error) error\n    OnProviderSelected(ctx context.Context, provider types.Provider) error\n}\n\n// RouteRegistrar allows extensions to register custom routes\ntype RouteRegistrar interface {\n    Handle(pattern string, handler http.Handler)\n    HandleFunc(pattern string, handler http.HandlerFunc)\n}\n\n// ExtensionRegistry manages extension lifecycle\ntype ExtensionRegistry interface {\n    Register(ext Extension) error\n    Get(name string) (Extension, bool)\n    List() []Extension\n    Initialize(configs map[string]backendtypes.ExtensionConfig) error\n    Shutdown(ctx context.Context) error\n}\n\n// BaseExtension provides default implementations for optional methods\ntype BaseExtension struct{}\n\nfunc (b *BaseExtension) Dependencies() []string { return nil }\nfunc (b *BaseExtension) RegisterRoutes(r RouteRegistrar) error { return nil }\nfunc (b *BaseExtension) BeforeGenerate(ctx context.Context, req *backendtypes.GenerateRequest) error { return nil }\nfunc (b *BaseExtension) AfterGenerate(ctx context.Context, req *backendtypes.GenerateRequest, resp *backendtypes.GenerateResponse) error { return nil }\nfunc (b *BaseExtension) OnProviderError(ctx context.Context, provider types.Provider, err error) error { return nil }\nfunc (b *BaseExtension) OnProviderSelected(ctx context.Context, provider types.Provider) error { return nil }\nfunc (b *BaseExtension) Shutdown(ctx context.Context) error { return nil }\n```\n\n**File:** `pkg/backend/extensions/registry.go`\n\n```go\npackage extensions\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n\n    \"github.com/anthropics/ai-provider-kit/pkg/backendtypes\"\n)\n\ntype registry struct {\n    mu         sync.RWMutex\n    extensions map[string]Extension\n    order      []string\n}\n\nfunc NewRegistry() ExtensionRegistry {\n    return \u0026registry{\n        extensions: make(map[string]Extension),\n        order:      make([]string, 0),\n    }\n}\n\nfunc (r *registry) Register(ext Extension) error {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    name := ext.Name()\n    if _, exists := r.extensions[name]; exists {\n        return fmt.Errorf(\"extension %s already registered\", name)\n    }\n\n    r.extensions[name] = ext\n    r.order = append(r.order, name)\n    return nil\n}\n\nfunc (r *registry) Get(name string) (Extension, bool) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    ext, ok := r.extensions[name]\n    return ext, ok\n}\n\nfunc (r *registry) List() []Extension {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    result := make([]Extension, 0, len(r.extensions))\n    for _, name := range r.order {\n        result = append(result, r.extensions[name])\n    }\n    return result\n}\n\nfunc (r *registry) Initialize(configs map[string]backendtypes.ExtensionConfig) error {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    sorted, err := r.topologicalSort()\n    if err != nil {\n        return fmt.Errorf(\"dependency resolution failed: %w\", err)\n    }\n\n    for _, name := range sorted {\n        ext := r.extensions[name]\n        cfg, ok := configs[name]\n        if !ok || !cfg.Enabled {\n            continue\n        }\n        if err := ext.Initialize(cfg.Config); err != nil {\n            return fmt.Errorf(\"failed to initialize extension %s: %w\", name, err)\n        }\n    }\n    return nil\n}\n\nfunc (r *registry) Shutdown(ctx context.Context) error {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    for i := len(r.order) - 1; i \u003e= 0; i-- {\n        name := r.order[i]\n        if err := r.extensions[name].Shutdown(ctx); err != nil {\n            return fmt.Errorf(\"failed to shutdown extension %s: %w\", name, err)\n        }\n    }\n    return nil\n}\n\nfunc (r *registry) topologicalSort() ([]string, error) {\n    // Topological sort implementation for dependency ordering\n    visited := make(map[string]bool)\n    result := make([]string, 0, len(r.extensions))\n\n    var visit func(name string) error\n    visit = func(name string) error {\n        if visited[name] {\n            return nil\n        }\n        visited[name] = true\n\n        ext, ok := r.extensions[name]\n        if !ok {\n            return nil\n        }\n\n        for _, dep := range ext.Dependencies() {\n            if err := visit(dep); err != nil {\n                return err\n            }\n        }\n\n        result = append(result, name)\n        return nil\n    }\n\n    for _, name := range r.order {\n        if err := visit(name); err != nil {\n            return nil, err\n        }\n    }\n\n    return result, nil\n}\n```\n\n**Acceptance Criteria:**\n- [ ] Extension interface defined with all lifecycle methods\n- [ ] BaseExtension provides sensible defaults\n- [ ] Registry handles registration and lifecycle\n- [ ] Topological sort for dependency ordering\n- [ ] Unit tests for registry operations","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:21.838118915Z","updated_at":"2025-11-29T02:04:48.655974183Z","dependencies":[{"issue_id":"workspace-fc4","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.076997299Z","created_by":"daemon"}]}
{"id":"workspace-ksq","title":"APK 1.2: Define Backend Configuration Types","description":"#### Task 1.2: Define Backend Configuration Types\n**Priority:** P0 - Blocking\n**Estimated Effort:** 4 hours\n\n**File:** `pkg/backendtypes/config.go`\n\n```go\npackage backendtypes\n\nimport (\n    \"time\"\n    \"github.com/anthropics/ai-provider-kit/pkg/types\"\n)\n\n// BackendConfig defines the configuration for the backend server\ntype BackendConfig struct {\n    Server     ServerConfig                      `yaml:\"server\"`\n    Auth       AuthConfig                        `yaml:\"auth\"`\n    Logging    LoggingConfig                     `yaml:\"logging\"`\n    CORS       CORSConfig                        `yaml:\"cors\"`\n    Providers  map[string]*types.ProviderConfig  `yaml:\"providers\"`\n    Extensions map[string]ExtensionConfig        `yaml:\"extensions\"`\n}\n\ntype ServerConfig struct {\n    Host            string        `yaml:\"host\"`\n    Port            int           `yaml:\"port\"`\n    Version         string        `yaml:\"version\"`\n    ReadTimeout     time.Duration `yaml:\"read_timeout\"`\n    WriteTimeout    time.Duration `yaml:\"write_timeout\"`\n    ShutdownTimeout time.Duration `yaml:\"shutdown_timeout\"`\n}\n\ntype AuthConfig struct {\n    Enabled     bool     `yaml:\"enabled\"`\n    APIPassword string   `yaml:\"api_password\"`\n    APIKeyEnv   string   `yaml:\"api_key_env\"`\n    PublicPaths []string `yaml:\"public_paths\"`\n}\n\ntype LoggingConfig struct {\n    Level  string `yaml:\"level\"`\n    Format string `yaml:\"format\"` // \"json\" or \"text\"\n}\n\ntype CORSConfig struct {\n    Enabled        bool     `yaml:\"enabled\"`\n    AllowedOrigins []string `yaml:\"allowed_origins\"`\n    AllowedMethods []string `yaml:\"allowed_methods\"`\n    AllowedHeaders []string `yaml:\"allowed_headers\"`\n}\n\ntype ExtensionConfig struct {\n    Enabled bool                   `yaml:\"enabled\"`\n    Config  map[string]interface{} `yaml:\"config\"`\n}\n```\n\n**Acceptance Criteria:**\n- [ ] All configuration types defined\n- [ ] YAML tags for serialization\n- [ ] Default values documented\n- [ ] Unit tests for config validation","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:15.445620167Z","updated_at":"2025-11-29T02:04:34.539681176Z","dependencies":[{"issue_id":"workspace-ksq","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.024479113Z","created_by":"daemon"}]}
{"id":"workspace-l46","title":"APK 3.1: Add OAuth Handler","description":"#### Task 3.1: Add OAuth Handler\n**Priority:** P1 - High\n**Estimated Effort:** 8 hours\n\n**Acceptance Criteria:**\n- [ ] OAuth initiation endpoint\n- [ ] OAuth callback endpoint\n- [ ] Token refresh endpoint\n- [ ] Integration with oauthmanager","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:45.357392527Z","updated_at":"2025-11-29T02:04:49.109494228Z","dependencies":[{"issue_id":"workspace-l46","depends_on_id":"workspace-sqx","type":"blocks","created_at":"2025-11-29T02:00:40.330293091Z","created_by":"daemon"}]}
{"id":"workspace-sqx","title":"APK 2.5: Implement Backend Server","description":"#### Task 2.5: Implement Backend Server\n**Priority:** P0 - Blocking\n**Estimated Effort:** 8 hours\n\n**File:** `pkg/backend/server.go`\n\n**Features:**\n- Server initialization with config\n- Provider initialization (including virtual providers)\n- Extension initialization\n- Middleware application\n- Graceful shutdown\n- Integration tests\n\n**Acceptance Criteria:**\n- [ ] Server initialization with config\n- [ ] Provider initialization (including virtual providers)\n- [ ] Extension initialization\n- [ ] Middleware application\n- [ ] Graceful shutdown\n- [ ] Integration tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:44.370648254Z","updated_at":"2025-11-29T02:04:49.932470686Z","dependencies":[{"issue_id":"workspace-sqx","depends_on_id":"workspace-1nh","type":"blocks","created_at":"2025-11-29T02:00:39.268538144Z","created_by":"daemon"},{"issue_id":"workspace-sqx","depends_on_id":"workspace-2xd","type":"blocks","created_at":"2025-11-29T02:00:39.279677886Z","created_by":"daemon"},{"issue_id":"workspace-sqx","depends_on_id":"workspace-1x4","type":"blocks","created_at":"2025-11-29T02:00:39.289793681Z","created_by":"daemon"},{"issue_id":"workspace-sqx","depends_on_id":"workspace-2fy","type":"blocks","created_at":"2025-11-29T02:00:39.300876577Z","created_by":"daemon"}]}
{"id":"workspace-uud","title":"APK 2.1: Implement Base Handler Utilities","description":"#### Task 2.1: Implement Base Handler Utilities\n**Priority:** P0 - Blocking\n**Estimated Effort:** 4 hours\n\n**File:** `pkg/backend/handlers/base.go`\n\n**Acceptance Criteria:**\n- [ ] SendSuccess, SendError, SendCreated methods\n- [ ] ParseJSON for request parsing\n- [ ] Consistent response formatting\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:40.896157798Z","updated_at":"2025-11-29T02:04:30.768224913Z","dependencies":[{"issue_id":"workspace-uud","depends_on_id":"workspace-ksq","type":"blocks","created_at":"2025-11-29T02:00:39.20724421Z","created_by":"daemon"},{"issue_id":"workspace-uud","depends_on_id":"workspace-ezv","type":"blocks","created_at":"2025-11-29T02:00:39.21720205Z","created_by":"daemon"},{"issue_id":"workspace-uud","depends_on_id":"workspace-fc4","type":"blocks","created_at":"2025-11-29T02:00:39.226172251Z","created_by":"daemon"}]}
{"id":"workspace-xzt","title":"APK 1.6: Implement Load Balance Virtual Provider","description":"#### Task 1.6: Implement Load Balance Virtual Provider\n**Priority:** P1 - High\n**Estimated Effort:** 4 hours\n\n**File:** `pkg/providers/virtual/loadbalance/provider.go`\n\n```go\npackage loadbalance\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync/atomic\"\n\n    \"github.com/anthropics/ai-provider-kit/pkg/types\"\n)\n\n// LoadBalanceProvider distributes requests across providers\ntype LoadBalanceProvider struct {\n    name      string\n    providers []types.Provider\n    config    *Config\n    counter   uint64\n}\n\ntype Config struct {\n    Strategy      Strategy `yaml:\"strategy\"`\n    ProviderNames []string `yaml:\"providers\"`\n}\n\ntype Strategy string\n\nconst (\n    StrategyRoundRobin Strategy = \"round_robin\"\n    StrategyRandom     Strategy = \"random\"\n    StrategyWeighted   Strategy = \"weighted\"\n)\n\nfunc NewLoadBalanceProvider(name string, config *Config) *LoadBalanceProvider {\n    return \u0026LoadBalanceProvider{\n        name:   name,\n        config: config,\n    }\n}\n\nfunc (lb *LoadBalanceProvider) SetProviders(providers []types.Provider) {\n    lb.providers = providers\n}\n\nfunc (lb *LoadBalanceProvider) Name() string              { return lb.name }\nfunc (lb *LoadBalanceProvider) Type() types.ProviderType { return \"loadbalance\" }\nfunc (lb *LoadBalanceProvider) Description() string      { return \"Distributes requests across providers\" }\n\nfunc (lb *LoadBalanceProvider) GenerateChatCompletion(ctx context.Context, opts types.GenerateOptions) (types.ChatCompletionStream, error) {\n    if len(lb.providers) == 0 {\n        return nil, fmt.Errorf(\"no providers configured\")\n    }\n\n    provider := lb.selectProvider()\n\n    chatProvider, ok := provider.(types.ChatProvider)\n    if !ok {\n        return nil, fmt.Errorf(\"selected provider does not support chat\")\n    }\n\n    return chatProvider.GenerateChatCompletion(ctx, opts)\n}\n\nfunc (lb *LoadBalanceProvider) selectProvider() types.Provider {\n    switch lb.config.Strategy {\n    case StrategyRandom:\n        return lb.providers[randomInt(len(lb.providers))]\n    default: // Round robin\n        idx := atomic.AddUint64(\u0026lb.counter, 1) - 1\n        return lb.providers[idx%uint64(len(lb.providers))]\n    }\n}\n\nfunc randomInt(max int) int {\n    // Simple random selection\n    return int(time.Now().UnixNano() % int64(max))\n}\n```\n\n**Acceptance Criteria:**\n- [ ] Load balance provider implements types.Provider\n- [ ] Round-robin strategy\n- [ ] Random strategy\n- [ ] Thread-safe counter\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:20.0608568Z","updated_at":"2025-11-29T02:04:37.698466116Z","dependencies":[{"issue_id":"workspace-xzt","depends_on_id":"workspace-30d","type":"blocks","created_at":"2025-11-29T02:00:38.066228097Z","created_by":"daemon"}]}
{"id":"workspace-zh8","title":"APK 4.1: Documentation","description":"#### Task 4.1: Documentation\n**Priority:** P1 - High\n**Estimated Effort:** 8 hours\n\n**Documentation to Create:**\n- [ ] Package documentation\n- [ ] API documentation\n- [ ] Extension development guide\n- [ ] Virtual provider configuration guide\n- [ ] Migration guide\n\n**Acceptance Criteria:**\n- [ ] Package documentation complete\n- [ ] API documentation complete\n- [ ] Extension development guide complete\n- [ ] Virtual provider configuration guide complete\n- [ ] Migration guide complete","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T01:59:58.965516167Z","updated_at":"2025-11-29T02:05:11.799217288Z","dependencies":[{"issue_id":"workspace-zh8","depends_on_id":"workspace-sqx","type":"blocks","created_at":"2025-11-29T02:00:41.048178514Z","created_by":"daemon"},{"issue_id":"workspace-zh8","depends_on_id":"workspace-30w","type":"blocks","created_at":"2025-11-29T02:00:41.058054722Z","created_by":"daemon"}]}
